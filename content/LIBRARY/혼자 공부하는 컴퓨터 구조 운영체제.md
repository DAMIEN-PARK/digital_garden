---
tags:
  - OS
  - IT
  - Book
title: 혼자 공부하는 컴퓨터 구조 운영체제
Author:
  - 강민철
category: ""
Publisher: 한빛미디어
Publish: "2022"
Cover: https://shopping-phinf.pstatic.net/main_3382462/33824626625.20230627104236.jpg
Status:
  - ✔️Done
date: 2025-04-23
total: ""
isbn: "9791162243091"
isbn13: "9791162243091"
draft: false
---

![cover|150](https://shopping-phinf.pstatic.net/main_3382462/33824626625.20230627104236.jpg)
###  혼자 공부하는 컴퓨터 구조+운영체제
(1:1 과외하듯 배우는 컴퓨터공학 자습서)    
- 저자 : 강민철
### **Chapter 01 컴퓨터 구조 시작하기**  
#### 1-1 구조를 알아야 하는 이유  
__성능, 용량, 비용  
#### 1-2 컴퓨터 구조의 큰 그림  
![[Pasted image 20240830151754.png|500]]
- 정보 = 데이터 와 명령어
1. [[CPU]] : 메모리에 저장된 데이터와 명령어
2. [[Momory]] (보조기억장치): ALU(Arithmetic Logic Unit), 레지스터, 제어장치(CU;Control Unit)
3. Secondary storage 
4. Input/Output Device : 입출력 장치
- 메인보드 
- 시스템 버스 : 주소버스, 데이터버스, 제어버스
	4가지 핵심 부품이 서로 주고받는 통로
[[라즈베리파이5]]
### Chapter 02 데이터  
#### 2-1 숫자 : 0과 1로 숫자
정보 단위
	이진법 : 아래첨자(2) 예) 100(2), 
		음수 = 2의 보수법 0과 1을 뒤빚고 거기에 1을 더함 
		-11 = 00 ▶더하기 1 ▶ 01(2)
	십육진법  : 10=a, 11=b ... 15=f
#### 2-2 문자 : 0과 1로 문자
문자 집합과 인코딩
	인코딩 : 코드화 하는 과정 0과1로 문자코드로 전환
	디코딩 : 인코딩 된 코드를 해석하는 과정
- 아스키 코드 : 알파벳, 아라비아 숫자, 특수 제어 문자(7비트 `2^7`), 한글처럼 다양한 문자 표현 힘듬. 128개가 한계
- EUC-KR  (한글인코딩) : 완성형 (글자하나 2byte=16bit), 조합형(ㅈ ㅗ ㅎ ㅏ ㅂ ㅎ ㅕ ㅇ): 설믜 이름 불가능.
- 유니코드 : 통일된 문자집합 인코딩 하는 방법 → UTF-8  UTF-16  
	- UTF-8  : 가변길이 인코딩(1~4Byte)
### Chapter 3 명령어
#### 3-1 소스 코드와 명령어  
고급 언어와 저급 언어  
	고급언어(C언어, Java, Python) → 저급언어(기계어_Machine code(2,16진법)와 어셈블리어Assembly Language) 로 변환
	![[Pasted image 20240830170922.png|500]]
 컴파일 언어와 인터프리터 언어  
 
 ![[Pasted image 20240830170952.png|500]]
- 과정 : 소스코드 ▶ 컴파일(소스코드 전체를 살펴봄) ▶ 목적코드(Object code)
- 인터프리트 언어(고급언어) : 인터프리터에 의해 ==한줄씩 실행== ,컴파일과 다름, 기다릴 필요 없음
	![[Pasted image 20240830171352.png|500]]
	https://godbolt.org/ 
	컴파일 언어와 인터프리트 언어가 양분 되는 개념은 아님
	📛 목적 파일 vs 실행 파일  
#### 3-2 명령어의 구조  
- 연산 코드와 오퍼랜드  
	![[Pasted image 20240830172111.png|500]]
- 연산코드Operation code | 오퍼랜드Operland
	연산코드 : CPU 마다 각기 다름. 
	1. 데이터 전송
	2. 산술/논리 연산
	3. 제어흐름 변경
	4. 입출력제어
	- 대표적인 유형 : move 옮겨라| sotre:메모리에 저장해라 | load : 메모리에서 가져와라
	- 연산코드 종류
		- Stack : 한쪽 끝이 막혀 있는 구조이며 LIFO 마지막 것이 먼저나옴
		![[Pasted image 20240830172554.png|500]]
		- Queue : 양쪽 뚫려있음 FIFO
		![[Pasted image 20240830172717.png|500]]
		Halt : 멈춰라 , Call: 특정 함수 실행 순서 Return : call 로 돌아가서 실행
	오퍼랜드(연산에 사용될 데이터가 저장 된 위치), 없거나 하나 이상
	
 - 주소 지정 방식  
 
 명령어 주소 지정방식 Addressing mode  
	 유효주소 Effective address : 연산에 사용될 데이터가 저장된 위치
	즉시 주소 지정 방식 : 연산에 사용될 데이터 크기가 작아질 수 있긴 한데 빠름
	직접 주소 지정 방식 : 유효 주소를 직접 명식( 연산코드 만큼 줄어들 수 있음)
	간접 주소 지정 방식 : 유효주소의 주소를 명시 메모리 뒤적거려서 속도 느림. 
	레지스터 주소 지정 방식 : 연산에 사용될 데이터가 저장된 레지스터를 명시
		메모리에 접근하는 속도 보다 ==레지스터에 접근하는게 빠름==
	 레지스터 간접 주소 지정 방식 메모리에 저장 하고 유효주소 저장 레지스터를 명시
	 다양한 주소 지정 방식
컴파일과정 : 전처리기(Preprocessing) ▶ 컴파일러 ▶ 어셈블러 ▶ 링커
전처리기 : 외부에 선언된 소스 코드 라이브러리 포함. 매크로 변환. 영역표시. 컴파일 하기 위한 준비

### Chapter 4 CPU와 작동 원리

#### 4-1 ALU와 제어장치  
![[Pasted image 20240830233912.png|500]]
ALU (계산기) → 임시값을 레지스터에 저장
플래그[[flag]] : 연산 결과에 대한 부과 정보 ▶ 플래그 레지스터 라는 특수한 레지스터에 담김, 
	![[Pasted image 20240830234232.png|500]]
제어장치  : 받는것 : 해석할 명령어, 쿨럭, 플래그, 제어신호 / 내보내는 것 : 제어신호
	![[Pasted image 20240830234436.png|500]]
	쿨럭 : 모든 부품을 일사분란하게 움직일 수 있게 하는 ==시간단위==
	명령어 레지스터 부터 해석할 명령어를 받음.
#### 4-2 레지스터  
레지스터 : CPU 내부의 작은 임시저장장치 
특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식  
1. 프로그램 카운터 : 메모리에서 가져올 명령어의 주소 저장 instruction pointer
2. 명령어 레지스터 : 해석할 명령어를 저장 (방금 메모리에서 읽어들인 명령어)
3. 메모리 주소 레지스터 : 메모리 주소 저장 CPU가 주소 버스를 이용
4. 메모리 버퍼 레지스터 : 메모리와 주고 받을 값
5. 플래그 레지스터 : CPU 상태 부가적인 정보 저장 레지스터
6. 범용 레지스터 : 일반적인 상황
특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식 
7. 스택 포인터 : 스택의 꼭대기를 가리키는 레지스터(스택이 어디까지 차있는지 표시) 스택은 메모리 안에 영역이 있음
8. 베이스 레지스터 : 기준주소 역할. 
	베이스 레지스터 주소 지정 방식 오퍼랜드와 베이스 레지스터의 값 더해서 유효 주소 얻음

📛 상용화된 CPU 속 레지스터 및 주소 지정 방식   
#### 04-3 명령어 사이클과 인터럽트  
명령어 사이클  : 정해진 주기 흐름 메모리 값을 CPU에 인출  하는것 **인출 사이클**. 실행하는 것 = **실행 사이클**
	![[Pasted image 20240831000859.png]]
	

- 인터럽트  : 정해진 흐름을 방해하는 신호가 CPU로 오는걸 끊는것
	CPU가 주목해야 하거나, 얼른 처리해야 하는 다른작업 생길때
	- 동기(예외) 인터럽트 : 폴트 트랩 중단 소프트웨어 인터럽트
	- 비동기 인터럽트(하드웨어 인터럽트) : 주로 입출력 장치에 의해서 발생
1. 입출력 장치 CPU에 입터럽트 요청 신호를 보냄
2. CPU는 실행 사이클 끝나고 명령어를 인출하기 전 항상 인터럽트 여부 확인 함
3. CPU는 인터럽트 요청 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아 들일 수 있는 지 여부 확인
	![[Pasted image 20240831001725.png|500]]
4. 인터럽트를 받아 들일 수 있다면 CPU는 백업 시작
5. CPU는 인터럽트 벡터(각각의 인터럽트를 구분하기 위한 벡터,식별정보)를 참조하여 인터럽트 서비스루틴(Memory안에서 실행되는 프로그램)을 실행
6. 인터럽트 서비스루틴 실행 끝나면 4‍⃣에서 백업 해둔 작업 복구해서 실행 재개
![[Pasted image 20240831002556.png|500]]
📛 예외의 종류  
### Chapter 5 CPU 성능 향상 기법
#### 5-1 빠른 CPU를 위한 설계 기법  
컴퓨터는 쿨럭 신호에 맞춰 움직이고 명령어 사이클에 맞게 움직임. 
헤르츠(Hz) : 클럭이 똑-딱- 하고 1초에 한번 반벅 = 1Hz, 4.9 GHz = 1초에 클럭이 49억번 반복
클럭 : 
##### 코어와 스레드
- 코어 : 전통적으로는 명령어를 실행하는 부품은 1개만 존재
	멀티 코어  : 2개 이상 CPU. 코어가 많다고 빠르지 않음. 조별과제 같아서 적절하게 분배돼야 함
- 스레드(Thread) : 실행 흐름 단위
	하드웨어적 스레드 : 하나의 코어가 동시에 하나의 명령어 처리. 
	소프트웨어적 스레드 : 하나의 프로그램에서 독립적으로 실행되는 단위. 1코어 1스레드도 여러개의 소프트웨어 스레드 만들수 있음
	멀티스레드  : 2코어 4스레드, 두개의 스택 쌓을 수 있음. 
	논리프로세서
	![[Pasted image 20240831093022.png|500]]
	- 내컴퓨터
		![[Pasted image 20240831093137.png]]

#### 5-2 명령어 병렬 처리 기법
명령어 파이프라인
- 처리과정 : 명령어인출 → 해석 → 실행 → 결과 → 결과 저장
- 명령어 파이프 라인 :  CPU가 각 단계를 동시에 실행 
	![[Pasted image 20240831093451.png]]
- 파이프라인 위험Hazard : 
	- 데이터 위험 : 명령어 간의 의존성에 의해 야기 됨. 해석하는 동안 인출 할 수는 없음
	- 제어위험 : 프로그램 카운터가 갑작스레 바뀜. 분기예측(Branch prdiction-방지)
	- 구조적 위험 : 서로 다른 명령어가 같은 CPU 부품 (동시에 ALU와 레지스터)
- 슈퍼스칼라 : CPU 내부에 여러개의 명령어 파이프 라인을 포함한 구조, 파이프라인 위험도 증가 때문에 비례해서 빨라지지 않음
	![[Pasted image 20240831094145.png]]
- 비순차적 명령어 처리  OoOE : 새치기 , 파이프 라인이 원할하게 동작할 수 있음 
	![[Pasted image 20240831094305.png]]
#### 5-3 CISC와 RISC  
"CPU는 명령어를 실행한다" CPU마다 이해하는 종류가 다름
- 명령어 집합 : CPU가 이해할 수 있는 명령어들의 모음. CPU의 언어
	![[Pasted image 20240831094942.png|500]]
##### 명령어 집합구조ISA(Instruction Set Architecture) :  CPU의 언어
- CISC(Complex Instruction Set Computer) : 복잡하고 다양한 명령어(가변길이) 집합을 활용하는 컴퓨터(CPU)
	인텔, AMD : x86, x86-64 기반 
	상대적으로 적은 수의 명령으로 실행 
	단점 : 명령어 파이프라이닝이 불리함. 명령어 크기와 실행되기까지 일정하지 않음. 길이가 지멋대로라서 2클럭 4클럭
- RISC(Reduced Instruction Set Computer) : 명령어 종류 적고 가급적 1클럭 으로 규격화된 명령어 사용
	ARM 메모리 접근최소화(load Store) : 레지스터를 충분히 활용
	CISC 명령어가 많음. 
- CISC와 RISC 차이![[Pasted image 20240831095855.png]]
- 현대 CISC는 내부적으로 잘게 쪼개서 사용하기 때문에 RISC처럼 사용함. 
### Chapter 6 메모리와 캐시 메모리
#### 6-1 RAM의 특징과 종류
- RAM의 특징 : 휘발성 저장 장치
- RAM의 용량과 성능  
	(보조기억장치) 책장-(메모리) 책상
- RAM의 종류  
	- DRAM(Dynamic RAM) : 저장된 데이터가 저절로 사라짐, 전원이 있어도 Refresh 해줘야 됨. 집적도가 높아서 오밀조밀하게 대용량으로 설계하기 좋음. 실제로 메모리로 사용. 가격도 저렴
	- SRAM(Static RAM) : 정적인 RAM 사라지지 않음. DRAM보다 일반적으로 빠름. 집적도가 낮아 대용량 어려움. 빠르게 사용해서 캐쉬메모리에서 사용
	- DRAM vs SRAM
		- ![[Pasted image 20240831100927.png]]
	- SDRAM(Synchronous DRAM ) : 클럭신호와 동기화 됨 데이터를 한번씩 주고 받음. 
	- DDR SDRAM(Double Data Rate SDRAM) : 특별한 발전된 SDRAM 현재 대중적으로 사용되는 RAM. 대역폭이 2배 넓음
		![[Pasted image 20240831101201.png|500]]
	- DDR2 SDRAM
		![[Pasted image 20240831101314.png|500]]
	DDR2, DDR3 DDR4 SDRAM 16배
- DDR4 SDRAM : 현재 가장 대중적으로 사용되는 RAM
#### 6-2 메모리의 주소 공간  
논리주소와 물리주소
	![[Pasted image 20240901115026.png]]
	메모리에 저장된 값은 계속 변함. 
	물리 주소 : 메모리 입장에서 바라본 주소 겹치는 주소가 없음. ==실제 하드웨어==상 주소
	논리주소 : CPU에 실행중 프로그램에 0번지부터 시작 되는 주소.
	- MMU(메모리 관리 장치) 라는 하드웨어에 의해 변환
	논리주소(프로그램 시작점에서 떨어진 거리) + 베이스 레지스터(가장 작은 물리주소) 값 => 논리주소를 물리주소로 변환
		![[Pasted image 20240901115445.png]]

메모리 보호 기법 : CPU는 메모리 접근하기 전 접근하고자 하는 노리주소가 한계 레지스터보다 작은지 항상 검사
	한계레지스터 : 프로그램 영역 침범 명령어 실행을 막음 
	베이스 레지스터 값 <= 프로그램의 < 베이스 레지스터 +한계레지스터 값
	- 메모리 보호
	![[Pasted image 20240901133742.png|500]]
#### 6-3 캐시 메모리  
저장 장치 계층 구조 
- CPU와 가까울수록 빠름 : 
- 속도가 빠른 저장 장치는 용량이 작고 비쌈
크기와 빠른 순서 : 레지스터(비쌈) > 캐쉬메모리 >  RAM > USB메모리 (쌈)
- 캐시 메모리  
	CPU와 메모리 사이에 위치한 SRAM 기반의 저장장치
	CPU 연산 속도와 메모리 접근 속도 차이를 줄이고자 탄생 
	CPU가 매번 메모리에 왔다갔다 시간 오래걸림. ▶ 미리 캐쉬메모리에 가져옴
- 캐시 메모리 
	- 메모리 접근 = 물건사러 가는 것, 캐쉬메모리= 편의점
	![[Pasted image 20240901134233.png|500]]
	- 캐쉬메모리 설계방식 : CPU코어 내에 L1 L2, 코어외부에 L3 
		![[Pasted image 20240901134423.png]]
	- 멀티코어 프로세서 캐시메모리 : 코어마다 따로 하거나 L3공유
		![[Pasted image 20240901134529.png|500]]
	분리형 캐쉬 존재
	레지스터 - L1 캐쉬 - L2 캐쉬 - L3 캐쉬 - 주기억 장치 - 보조기억장치 
참조 지역성 원리  : CPU가 자주 사용할 법한 내용을 예측하는 원리
	CPU는 최근 접근했던 메모리 공간에 다시 접근하는 경향
	공간지역성 : CPU 는 접근한 메모리 공간 근처를 접근하려는 경향
- 캐시 히트 :  CPU가 자주 사용할 법한 내용을 예측하여 저장하여 실제로 들어 맞음. 
- 캐시 미스 : 예측이 틀려 메모리에서 직접 가져와야 하는 경우.
- 캐시 적중률 : 캐시 히트횟수 / (캐시 히트횟수 + 캐시 미스 횟수)

### Chapter 7 보조기억장치
#### 7-1 다양한 보조기억장치  
하드 디스크 (HDD) : 자기적인 방식, 
	Platter 안에 Track 과 Sector , 여러겹의 같은 트랙이 모여 Cylinder(연속된 정보는 여기 기록)
##### 플래시 메모리(SSD,USB, SD) :범용성 넓은 저장 장치
Cell 데이터 저장하는 가장 작은 단위 
	Page block plane die
	삭제는페이지보다 큰 블록 단위로 이뤄짐. 쓰레기 값 때문에 
	상태 
		Free : 새로운 데이터 저장 가능(데이터 저장 돼있지 않음)
		Vaild : 이미 유효
		Invaild : 유효하지 않은 데이터(쓰레기값) 저장
		가비지 컬렉션 : 유효한 페이지 들만 새로운 블록으로 복사 후 기존의 블록 삭제
		![[Pasted image 20240902151252.png|500]]
SLC(1bit), MLC(2bit), TLC(3bit), QLC(4bit)
	SLC는 한집에 한명 MLC는 한집에 2명 .... 사는 구조
	SLC 한집에 한명이 빠르고 수명이 길다. 대신 월세 혼자 부담해야 하니 비싸다
	MLC, TLC : SLC보다느린 입출력 짧은 수명, 저렴해서 시중에서 많이 사용(USB SDcard )
	같은 플래시 메모리도 수명/가격/용량이 다르다
###### 종류
NAND flash Memory
NOR flash Memory
#### 7-2 RAID의 정의와 종류  
RAID의 정의  
Redundant Array of Independent Disks
안정성 또는 성능을 위해서 ==물리적 보조기억 장치를 하나의 논리적 보조기억장치==처럼 사용하는 기술 
1TB 다섯개가 아니라 5 TB 하나처럼 쓰고 싶을때
##### RAID의 종류  
RAID level 이 존재 0 1 2 3 4 5
RAID0 : 데이터 번걸아 가면서 데이터 저장 
	![[Pasted image 20240902151624.png|500]]
	Stripe : 줄무늬 처럼 분산되어 저장된 데이터,  Striping : 분산하여 저장
	나눠서 저장했기에 동시에 가능 따라서 ==입출력 속도가 빠름==
	정보가 안전하지 않을 수 있음
RAID1 : 미러링 방식. 속도가 느림(특히 쓰기 속도) 또 사용용량이 작아짐.
	![[Pasted image 20240902151847.png|500]]

- RAID4 : RAID1처럼 복사본 대신 패리티 비트를 저장. 
	패리티 저장한 장치를 이용 다른 장치들의 오류를 검출하고 오류 있을시 복구.
	![[Pasted image 20240902152108.png|500]]
	단점: 디스크 병목 현상
- RAID5 : 패리티 정보를 분산해서 저장해서 안정성 높음
- RAID6 : 두종류의 패리트 (오류를 검출) 더 안정 당연히 쓰기 속도 RAID5보다 느림. 
### Chapter 8 입출력장치
입출력 장치는 너무 다양하고 많다. 입출력 데이터 전송률은 낮음
#### 8-1 장치 컨트롤러와 장치 드라이버  
- 장치 컨트롤러 : 하드웨어. 모든 입출력 장치는 연결 돼있음. 
	CPU와 입출력장치간 통신 중개(번역기역할), 오류검출, 데이터버퍼링(버퍼라는 임시 저장장치에 저장 해서 전송률을 비)
	- 구조
		![[Pasted image 20240902153318.png|500]]
	- 데이터 레지스터 : CPU-입출력장치 사이 주고받을 데이터가 담기는 레지스터(버퍼)
	- 상태 레지스터 : 상태정보 저장
	- 제어 레지스터 : 수행할 내용 대한 정보
- 장치 드라이버(Device Driver) : 장치를 동작시키는 프로그램S/W
#### 8-2 다양한 입출력 방법  
##### 프로그램 입출력 : 입출력 명령어로써 장치 컨트롤러와 상효작용 
- 
	하드디스크에 새로운 정보 쓰기 = 백업
	제어 레지스터에 '쓰기'  명령어 보냄
	CPU가 장치 컨트롤러의 레지스터 갑을 읽고 씀
![[Pasted image 20240902154557.png]]
	- 메모리맵 입출력 Memory mapped I/O : 메모리 접근 명령어=입출력장치 접근 명령어 하나로 간주 ![[Pasted image 20240902155138.png]]
	- 고립형 입출력 Isolated I/O 
	별도의 주소 1,024개 공간을 입출력 전용 명령어를 사용
	![[Pasted image 20240902155236.png]]
	- 메모리맵 과 고립형 입출력 비교교![[Pasted image 20240902155336.png]]
##### 인터럽트 기반 입출력 
- 
	인터럽트 : CPU 싸이클 낭비를 막기 위해 알람같음, flag 안에도 하드웨어 인터럽트 존재
	동시다발 인터럽트 : 순차적으로 처리 , 우선순위 반영한 인터럽트 
	PIC(Programmable Interrupt Controller)라는 하드웨어를 사용. NMI는 아님

![[Pasted image 20240902160149.png]]
	직접 확인도 가능
	![[Pasted image 20240902160256.png]]
- 입출력 장치-메모리 사이 모든 데이터는 CPU가 주도하고 반드시 CPU를 거침. CPU는 바쁨
	![[Pasted image 20240902160331.png|500]]
##### DMA 입출력 : Direct Memory Access 
- CPU 를 거치지 않음. 시작과 끝만 관여
	![[Pasted image 20240902160523.png|500]]
	DMA 컨트롤러가 CPU의 역할을 대행 해서 메모리에 직접 접근해서 읽고/쓰기 가능 CPU는 작업완료만 전송
	DMA 컨트롤러는 조금씩 시스템 버스를 쓰거나, CPU가 일시적으로 Request를 구하고 시스템 버스 사용
- 장치컨트롤러가 System bus로 직접적으로 연결 괜찮은가? 입출력 버스를 통해서 system bus 사용 빈도 낮추는게 필요. **입출력 버스**
	PCI bus 여러종류
	- 슬롯들이 입출력버스 ![[Pasted image 20240902161157.png|300]]
	현재는 입출력전용 프로세서 채널이 등장해서 RAM이나 CPU까지 탑재해서 나옴.
## 운영체제 
### Chapter 09 운영체제 시작하기
#### 09-1 운영체제를 알아야 하는 이유  
![[Pasted image 20250123122637.png|300]]

- 운영체제 CPU 관리
	- 어떤 프로그램을 먼저, 또 얼마나 실행해야하는지 문제 해결
	- 입/출력 장치 관리
	- ![[Pasted image 20250123122922.png|300]] 하드웨어와 연결고리
	- 운영체제는 "정부Goverment" 에 비유가 많이 됨. 
		- ![[Pasted image 20250123123005.png|500]]
- 운영체제는 ~~사용자를 위한게 아니라~~  프로그램을 위한 프로그램
- 프로그램을 만드는 개발자는 운영체제의 도움을 받으면서 실행되기 때문에 알아야 함. 
#### 09-2 운영체제의 큰 그림  
  운영체제의 심장 **커널**
  ![[Pasted image 20250123124247.png|300]]
  유저 인터페이스 : 운영체제이지만 커널에 속하지 않음
	  그래픽 인터페이스
	  커맨드 이터페이스

자원에 직접 접근은 위험하다. 따라서 운영체제(OS)를 통해서 접근

- 이중모드 
	CPU가 명령어를 실행하는 모드를 크게 사용자 모드 커널모드로 나눔
	- 사용자 모드 : 운영체제 서비스 제공x / 커널영역 코드 실행 x/  자원에 접근 불가
	- 커널 모드 : 운영 체제 서비스를 제공 받음.  / 자원에 접근 과 명령어 실행 가능
	- 
- 시스템 호출
	- 커널 모드로 전환하기 위해 인터럽트를 걸어주는 것.
	- ![[Pasted image 20250123125058.png|400]]
	- ![[Pasted image 20250123125148.png|500]]

#### 운영체제의 핵심 서비스  
##### 프로세스 관리
- 프로세스 == 실행중인 프로그램
- 수많은 프로세스들이 동시에 실행 되고 있음.![[Pasted image 20250123180709.png|500]]
##### 자원 접근 및 할당
- CPU : CPU 스케쥴링 : 어떤 프로세스를 먼저 얼마나 오래실행할지 결정.
- 메모리 : 페이징, 스와핑 . . . 
	- ![[Pasted image 20250123180907.png|500]]
- 입출력 장치 : 하드웨어  interrupt service routine 제공해서 제어/할당
- 파일 시스템 관리 : 파일/폴더(디렉토리)
- 
📛 가상 머신과 이중 모드의 발전  

📛 시스템 호출의 종류  
https://minchul.net/self-learning-cs/system_calls/syscalls.html
커널 체제의 운용 코드를 실행함. 
윈도우 - 리눅스(맥OS)
### Chapter 10 프로세스와 스레드
#### 10-1 프로세스 개요  
##### 프로세스 직접 확인하기  
- foreground process : 사용자가 보는 앞에서 실행되는 프로세스: 게임/웹/워드/메모장..
- Background process : 
	- 사용자가 직접 상호작용
	- 상호작용 없이 일만 하는 프로세스(데몬daemon/서비스service)
##### 프로세스 제어 블록  PCB
![[Pasted image 20250124142445.png|200]] 태그에 정보들이 저장 된 자료구조. 종료되면 폐기
- 모든 프로세스는 CPU가 필요. 하지만 한정 돼 있음
 - 번갈아 수행 되는 프로세스 실행 순서를 관리하고 자원을 배분함. 
 - 자료구조(자료를 저장 하는 형태)
- ![[Pasted image 20250124142550.png|700]]
	- 프로세스 ID=PID : 특정 프로세스에 붙은 ID 값
	- 레지스터값 : 이전까지 실행했던 자료를 자신의 차리가 진행될때 재이용하기 위해
	- 프로세스 상태, cpu정보, 
	- 메모리 정보 : 페이지 테이블 정보(메모리 주소를 알 수 있는 정보가 담김)
	- 사용한 파일과 입출력 장치 정보 등이 담긴다. 
##### 문맥 교환  
- process A 가 이용하다가 process B에 넘어 갈때 : 지금까지의 중간정보(Context 문맥)를 백업
- 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행 되는 원리.
	- ![[Pasted image 20250124143537.png|500]]
##### 프로세스의 메모리 영역  

- 4개의 영역
	![[Pasted image 20250124143711.png|500]]
- 정적 할당 영역 (변하지 않음)
	- 코드영역 : 데이터가 아니라 CPU가 실행할 명령어 저장(쓰기 금지read-Only)
	- 데이터 영역 : 프로그램이 실행될 내내 유지할 데이터 (금방 없앨 데이터가 아님)(전역 변수)
- 동적 할당 영역
	- 힙 영역 : 사용자가 할당 가능. 프로그래머가 직접 할당 할수 있음/ 가비지 컬렉션으로 자동 반환 되거나 직접 반환 해야 함 안그러면 메모리 누수 발생
	- 스택 영역 : 데이터가 일시적으로 저장 되는 공간/ 잠깐 사용, 매개변수 지역변수
	![[Pasted image 20250124144215.png|500]]
	- 힙 영역과 스택 영역의 크기는 가변적임. 힙은 낮은주소에서 높은 주소로 할당. 스택 영역은 높은 주소에서 낮은 주소로 할당 되어 추돌을 방지지
#### 10-2 프로세스 상태와 계층 구조  
- 프로세스 상태  
	- ![[Pasted image 20250124163112.png|500]]
	- 생성 상태 : 막 메모리에 적재 되어 PCB를 할당 받은 상태
	- 준비 상태 : 당장 이라도 CPU 할당 받아 실행 가능. 즉 대기 상태 dispatch
	- 실행 상태 : CPU 를 할당 받은 시간, 실행도중 입출력 장치 사용시 대기 상태로 
	- 대기 상태 : 입출력 장치 사용 경우, 입출력작업은 CPU에 비해 느리기에 대기 상태로 접어둠. 입출력 끝나면 준비상태로
	- 종료 상태 : 프로세스 종료 상태 PCB 프레세스 메모리 정리
PCB에 기록 되는  상태
##### 프로세스 계층 구조  
- 윈도우는 계층으로 하진 않지만
- 부모parent 프로세스- 자식child 프로세스 
	- 각기 다른 PID값을 가짐. PPID를 명시하기도 함parent PID. 
	- ![[Pasted image 20250124163425.png|500]]
		- 10 개의 프로세스가 사용중이다.
	- ![[Pasted image 20250124163507.png|500]]
		- 로그인 프로세스 - bash 사용자 인터페이스 프로세스 - vim 이라는 자식 프로세스 만듬.
##### 프로세스 생성 기법  
- (윈도우 운영체제와는 관련없음 )
- 비유  : 복제와 옷갈아입기
	- 부모 프로세스는 **fork 시스템 호출** 을 통해 자신의 복사본을 자식 프로세스로 생성 (복제)
		- ![[Pasted image 20250124164040.png|200]] 저장되는 메모리 위치는 다름.
	- 자식 프로세스는 **exec 시스템 호출** 을 통해 자신의 메모리 공간을 다른 프로그램으로 교체 (옷갈아입기)
		- 메모리 공간을 새로운 프로그램으로 덮어 씀. 
		- ![[Pasted image 20250124164236.png|400]]
	- ![[Pasted image 20250124164401.png|500]]
#### 10-3 스레드  
- 스레드  : 프로세스를 구성하는 실행흐름 단위
	- 단일 스레드 프로세스 : 실행흐름이 하나뿐인 프로세스
	- 멀티 스레드 프로세스 : 실행흐름이 여러개
		![[Pasted image 20250124164802.png|200]]
- 스레드 구성요소
	- 스레드 ID, 프로그램 카운터를 비롯한 레지스터 값, 스택
	- ![[Pasted image 20250124164930.png|300]]
	- 실행에 필요한 최소한의 최소한의 정보/ ==똑같은 자원(코드영역)을 공유 하고 있음.==
	- 요즘은 프로세스 단위보다 스레드 단위로 CPU를 할당 받음. 물론 전통적인 이야기는 프로세스 단위로 처리 한다고 함. 

- 멀티 스레드와 멀티 프로세스
	동일한 작업 수행하는 단일 스레드 프로세스 여러개(멀티프로세스) vs 하나의 프로세스를 여러 스레드로 실행(멀티 스레드)
	- ![[Pasted image 20250124165507.png|500]]
		- 물론 쓰기 시 복사 로 나눠서 할 수 있음
	- 프로세스를 fork 하면 코드/데이터 힙 영역 등 모든 자원이 복제 되어 저장
	- fork를 세번 네번하면 메모리에는 같은 프로세스가 통째로 세개 네개 적재. 
	- 스레드 들은 각기 다른 스레드 id / 프로세스가 가지는 자원을 공유
	- ![[Pasted image 20250124165919.png|500]]
	- 프로세스 끼리는 자원을 공유하지 않는다. 독립적으로 이용 (IPC 프로스세간 통신을 활용해 자원을 주고 받을 수 있긴 함)
	- 스레드는 프로세스 자원을 공유한다. 협력과 통신에 유리하다. (다만 때때로 문제가 된다. 전체가 무넺 됨.)
		- ![[Pasted image 20250124170011.png|500]]
##### 파이썬 코드로 다루기
- PID 위치 보기
```python
from multiprocessing import Process
import os
print("hello os")
# PID 확인
print("My PID is", os.getpid())

def foo():
    print('foo : child process:', os.getpid())
    # 부모 프로세스
    print('foo : parent process:', os.getppid())

if __name__ == "__main__":
    print('parent process:', os.getpid())
    child = Process(target=foo).start()
```

- Thread 위치 보기
```python
import threading
import os

def foo():
    print('foo : thread:', threading.get_native_id())    # thread id 호출
    print('foo : my PID is : ', os.getpid())    # process id 호출

if __name__ == "__main__":
    print("My PID is", os.getpid())
    thread1 = threading.Thread(target=foo).start()
    thread2 = threading.Thread(target=foo).start()
    thread3 = threading.Thread(target=foo).start()
```

### Chapter 11 CPU 스케줄링
#### 11-1 CPU 스케줄링 개요  
- 프로세스 우선순위  
	- 예시) 입출력 작업이 많은 프로세스의 우선순위는 >CPU 작업이 많은 프로세스의 우선순위보다 높다. 
	- PCB에 저장됨. 
- 스케줄링 큐  
	- 큐는 FIFO이지만 스케쥴링 큐는FIFO 일 필요는 없음
		- ![[Pasted image 20250125140719.png|300]]
	- 준비 큐와 대기 큐
		- 기다리는rady 줄 과 대기waiting하는 줄
		- ![[Pasted image 20250125140843.png|500]]
		- 대기큐
		- ![[Pasted image 20250125141126.png|500]]
		- ![[Pasted image 20250125141231.png|500]]
- 선점형과 비선점형 스케줄링  
	- preemptive scheduling선점형 : 자원을 강제로 빼앗아 다음 차례에 넘겨줌. 한 프로세스의 자원 독점을 막음.
	- ![[Pasted image 20250125141411.png|300]]
	- un-preemptive scheduling비선점형 : 독점하고 잇음

#### 11-2 CPU 스케줄링 알고리즘  
- 스케줄링 알고리즘의 종류  
##### 선입선처리  FCFS
- first come first served : 준비 큐에 사입된 순서대로 처리하는 스케쥴링
- 먼저 요청한 순서 대로
- ![[Pasted image 20250125170541.png|500]]
	- 기다리는 시간이 길어지는 단점(호위효과)convoy effect

##### 최단작업 우선
- Shortest job first 호위효과 방지 즉 짧은 시간부터
	- ![[Pasted image 20250125170714.png|500]]
##### 라운드 로빈
- Round robin : 쭉 돌아가면서 차례대로 한다. 
- 선입선처리 스케쥴링 + 타임 슬라이스(프로세스가 CPU 사용 시간이 정해져있음)
- ![[Pasted image 20250125170913.png|300]]
- 타임슬라이스가 중요 (호위효과가 생기거나, CPU과부화 걸릴수있음)
##### 최소 잔여 시간 우선
- SRT shortest remaining time 
- 최단 작업 우선 + 라운드 로빈
- 정해진 시간만큼 CPU  사용 + 남은 작업 시간이 가장 적은 프로세스
##### 우선순위 
- 프로세스 들에게 우선 순위 부여
- 최단 작업, 최소 잔여 시간 스케쥴링 모두 우선순위 스케쥴링 이라는 범주에 포함됨
- 단점 : Starvation 기아 현상. 우선순위가 낮은  프로세스는 끝끝내 실행 연기 돼서 안됨.
	- aging : 나이를 먹게 하는 효과 대기중인 우선순위가 낮은 프로세스를 한칸씩 증가 시킴
##### 다단계 큐 스케쥴링
- multilevel queue
- 우선 순위 별로 준비큐를 여러개 사용
	- ![[Pasted image 20250125171523.png|300]]
- 단점 : 큐간의 이동이 불가능함(낮은 우선순위는 계속 낮아 기아현상 발생)
##### 다단계 피드백 큐 스케쥴링
Multilevel feedback queue 
- 큐 간의 이동이 가능
- CPU 시간이 길면 우선순위가 낮아지고, 낮은 우선순위 큐에서 너무 오래 기다리면 우선순위를 높이는 방식. 
- CPU 스케쥴링 방식에 가장 일반적인 형태
	- ![[Pasted image 20250125172026.png|500]]

### Chapter 12 프로세스 동기화  
#### 12-1 동기화란  
- 자원의 일관성을 보장해야 한다. 즉 동기화(수행시기 맞춤)를 고려 해야 함.
- 동기화의 의미  
	- 공동의 목적을 위해 동시에 수행되는 프로세스가 존재 : word 라면 맞춤법, 정렬, 입력내용 표시
	- 실행순서 제어 : 올바른 순서대로
	- 상호 제어 : 동시 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기
- 실행순서 제어를 위한 동기화 reader writer problem
	- Writer : book.txt 파일에 저장하는 프로세서
	- Reader : Book.txt 파일에 저장된 값을 읽어들이는 프로세서
	- 실행 순서를 제어 해야함
- 상호 배제를 위한 동기화 : Bank Account problem
	- 공유가 불가능한 자원 : 프린트처럼 한번에 하나만 프로세스 
	- 잔액은 10만원인데, A는 2만원을 추가. 프로세스 B는 현재 잔액에 5만원 추가
		- ![[Pasted image 20250125172824.png|500]]
		- 잔액에 한번에 하나씩 해야 함.
- 생산자와 소비자 문제  produce and consumer problem
```
총합 = 10
생산자
	생산자(){
		버퍼에 데이터 삽입
		'총합' 변수 1 증가
	}

소비자 
	소비자 (){
		버퍼에서 데이터 빼내기
		'총합' 변수 1 감소
	}

생산자를 10만번, 소비자를 10만번 실행하면 총합은? 0 일까?
```
![[Pasted image 20250125173336.png|500]]
총합(전역변수)에 동시에 접근했기에 발생하는 오류

- 공유 자원과 임계 구역  
	- 임계구역 : 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역 '총액', '변수'
![[Pasted image 20250125173524.png|500]]
- 레이스 컨디션 :  임계 구역에 동시에 접근하면 자원의 일관성이 깨질수 있다.
- 상호배제를 위한 동기화 3가지 원칙
	- 상호배제mutual exclusion : 한 프로세스가 임계 구역에 진입하면 다른 프로세스 들어 올 수 없음
	- 진행progress :  임계구역에 어떤 프로세스도 진입하지 않았다면. 진입하고자 하는 프로세스는 들어갈 수 있어야 한다. 
	- 유한 대기 bounded waiting : 언젠가 들어갈 수 있어야 한다. 
#### 12-2 동기화 기법
##### 뮤텍스 락  
- mutex lock: mutual exclusion lock
- 상호배제를 위한 동기화 도구(탈의실같은 임계구역의 자물쇠 역할)
- 전역 변수(lock) 1개, 함수 2개 (Acquire함수+Release함수)
- 
##### 세마포  

##### 모니터    

### Chapter 13 교착 상태
#### 13-1 교착 상태란  
식사하는 철학자 문제  
자원 할당 그래프  
교착 상태 발생 조건  
#### 13-2 교착 상태 해결 방법  
교착 상태 예방  
교착 상태 회피  
교착 상태 검출 후 회복    
### Chapter 14 가상 메모리
#### 14-1 연속 메모리 할당  
스와핑  
메모리 할당  
외부 단편화  
#### 14-2 페이징을 통한 가상 메모리 관리  
페이징이란  
페이지 테이블  
페이징에서의 주소 변환  
페이지 테이블 엔트리  
📛 페이징의 이점 - 쓰기 시 복사  
📛 계층적 페이징  
#### 14-3 페이지 교체와 프레임 할당  
__요구 페이징  
__페이지 교체 알고리즘  
__스래싱과 프레임 할당  
### **Chapter 15 파일 시스템**
#### 15-1 파일과 디렉터리  
__파일  
__디렉터리  
📛 상대 경로를 나타내는 또 다른 방법  
#### 15-2 파일 시스템  
__파티셔닝과 포매팅  
__파일 할당 방법  
__파일 시스템 살펴보기  
📛 저널링 파일 시스템  
📛 마운트  

##### feedback




### Reference

유튜브 : [컴퓨터 구조](https://youtu.be/kFWP6sFKyp0?feature=shared)
유튜브 : [운영체제](https://youtu.be/isj4sZhoxjk?feature=shared)
