---
title: REST API란?
description: 
date:
  - - 2025-04-28
tags: 
draft: true
---

#  REST API란?
- **HTTP 프로토콜**을 기반으로 만들어진 **규칙(rule)** 
- 클라이언트(앱, 브라우저 등)가 서버에 **자원(Resource)** 을 요청하고, 서버가 요청에 따라 응답하는 구조
- **REST**는 **REpresentational State Transfer**의 약자입니다. (대표적인 상태 전달)
### 쉽게 예를 들면:
> **REST API**는 편의점처럼,  
> 내가 "콜라 하나 주세요" (요청) → 점원이 "콜라 여기 있습니다" (응답)  
> 요청-응답이 딱 정해진 방식으로 깔끔히 이뤄집니다.

#  기능적 측면에서 본 REST API

|항목|설명|
|---|---|
|**HTTP 메서드 사용**|GET(조회), POST(생성), PUT(수정), DELETE(삭제) 등 표준 HTTP 메서드를 사용합니다.|
|**자원 기반 접근**|URL을 통해 자원을 지정합니다. (예: `/users/1`은 1번 사용자를 의미)|
|**무상태성(Stateless)**|요청 간에 서버가 클라이언트의 상태를 기억하지 않습니다. 매 요청은 독립적입니다.|
|**캐시 처리 가능**|HTTP 기반이라 캐싱을 쉽게 적용할 수 있어 트래픽을 줄일 수 있습니다.|
|**표준화된 규칙**|명확한 규칙이 있어서 개발자 간 협업이 쉽고, 다양한 시스템과 연동이 수월합니다.|

#  객관적인 장점과 단점

|구분|내용|
|---|---|
|**장점**|- 구조가 단순하고 명확함- HTTP만 있으면 어디서나 작동 가능- 다양한 플랫폼(웹, 앱)과 쉽게 연동- 무상태성 덕분에 서버 확장이 쉬움|
|**단점**|- 아주 자주, 실시간으로 데이터가 바뀌는 시스템에는 부적합 (항상 요청을 새로 해야 함)- 연결 유지 기능이 없어서 서버 → 클라이언트 알림(push)이 어려움- 오버헤드가 존재 (매번 HTTP 헤더 붙음)|

# 📌 요약

> "REST API는 **HTTP 기반 요청/응답 구조**를 표준화한 방식으로,  
> **간단하고 범용적인 데이터 교환**에 최적화되어 있습니다.  
> 다만, 실시간 통신에는 약하고, **요청-응답 주기**에 따라야 한다는 제한이 있습니다."


#  웹소켓 vs REST API 비교

|항목|REST API|WebSocket|
|---|---|---|
|통신방식|요청 → 응답 (한 방향)|양방향(Full Duplex) 실시간 통신|
|연결 상태|요청마다 연결|한 번 연결하고 계속 유지|
|실시간성|낮음 (주기적 폴링 필요)|높음 (바로 전송 가능)|
|사용 예시|블로그, 쇼핑몰, CRUD 앱|채팅 앱, 게임, 주식 시세 알림|
|프로토콜|HTTP|WebSocket (초기에 HTTP 핸드셰이크)|

---

**정리 한마디:**

- **REST API**는 → "요청하고 답을 받는 깔끔한 규칙"
    
- **WebSocket**은 → "지속 연결로 서로 계속 대화하는 실시간 통신"
    

# ✅ RESTful 설계 원칙 6가지

|번호|원칙|아주 쉽게 설명|
|:--|:--|:--|
|1|**Uniform Interface (일관된 인터페이스)**|**접근 방법을 통일**한다. URL, 요청 방식(GET, POST 등), 데이터 포맷(JSON 등)이 항상 일정해야 한다. 👉 "규칙이 같으면 누구나 쉽게 이해하고 쓸 수 있다!"|
|2|**Stateless (무상태성)**|**서버는 클라이언트 상태를 기억하지 않는다.** 요청할 때마다 필요한 모든 정보를 보내야 한다. 👉 "한 번 요청할 때마다 완전히 독립적으로 처리!"|
|3|**Cacheable (캐시 가능성)**|**서버 응답은 캐시가 가능한지 표시해야 한다.** (ex: `Cache-Control` 헤더) 👉 "캐시를 활용하면 트래픽을 줄이고, 빠르게 응답할 수 있다!"|
|4|**Client-Server Architecture (클라이언트-서버 분리)**|**클라이언트(앱, 웹)와 서버는 역할이 구분되어야 한다.** 👉 "서버는 데이터 관리, 클라이언트는 화면 표시만 담당!"|
|5|**Layered System (계층화 시스템)**|**서버 구조를 여러 계층으로 나눌 수 있다.** (ex: 인증 서버, API 게이트웨이, 실제 데이터 서버) 👉 "중간 서버가 있어도 클라이언트는 몰라도 된다!"|
|6|**Code on Demand (선택적 기능)**|**서버가 클라이언트에 코드를 보내 실행시킬 수도 있다.** (예: 자바스크립트 동적 다운로드) 👉 "필요할 때만 클라이언트 기능을 확장할 수 있다!" (※ 필수는 아님, 선택사항)|

---

# 🎯 요약하면

|핵심 포인트|의미|
|:--|:--|
|일관성|URL, 메서드, 포맷 규칙을 지켜라|
|독립성|요청은 매번 독립적이어야 한다|
|효율성|캐시를 활용해 네트워크 최적화|
|역할 분리|서버와 클라이언트를 확실히 나눠라|
|계층 구조|중간 서버(게이트웨이 등)도 문제없게 설계|
|선택 기능|필요시 서버가 클라이언트 기능을 확장 가능 (Code on Demand)|

---

# ✅ 쉽게 기억하는 팁

> RESTful API를 잘 만들려면  
> **"규칙 지키고, 상태 기억 안 하고, 빠르고, 깔끔하게 분리하자!"**
> 
> (Code on Demand는 덤)


### Resources
