## 1과목
### 1. 이해
- 모델링 특징 : 추상화 단순화 명확화 
- 모델링 관점 : 데이터 / 프로세스 / DATA - PROCESS 상관 관점
- 외부단계 스키마 -(논리적 독립성 ) - 개념 단계 스키마 - (물리적 독립성)- 내부 단계 스키마 

- 데이터 모델링의 중요성 및 유의점
	- 중복 : 같은 시간 같은 데이터 제공
	- 비유연성 : 사소한 업무변화에 데이터 모델이 수시로 변경되면 안됨
	- 비일관성 : 신용 상태에 대한 갱신 없이 고객의 납부 이력 정보 갱신 안됨

데이터 독립성 요소
외부 스키마 : 개개 사용자가 보는 개인적 DB 스키마
개념 스키마 : 모든 사용자 관점을 통합한 전체 DB
내부 스키마 : 물리적 장치에서 데이터가 실제적 저장 데이터 독립성

논리적 독립성 : 개념 스키마가 변경되어도 외부 스키마에 영향 x
물리적 독립성 : 내부스키마가 변경되어도 외부/개념 스키마는 영향 x
Mapping(사상) : 상호 독립적인 개념을 연결시켜주는 다리

데이터 모델링의 3요소
어떤 것(Things)-성격(Attributes)-관계(Relationships)
데이터 모델링은 프로젝트에 참여한 모두가 알아야함

데이터 모델 표기법
1976년 피터첸이 Entity Relationship Model 개발
모델링의 특징 - 추상화, 단순화, 정확화
Entity Relationship Diagram 작업순서
1.엔터티 그림 
2.엔터티 배치 
3.엔터티 관계설정 
4.관계명 기술 
5.관계의 참여도 기술 
6.관계필수여부

좋은 데이터 모델의 요소
1.완전성 : 업무에 필요한 모든 데이터가 모델에 정의
2.중복배제 : 하나의 DB내에 동일한 사실은 한번만.
3.업무규칙 : 많은 규칙을 사용자가 공유하도록 제공
4.데이터 재사용 : 데이터가 독립적으로 설계돼야 함
5.의사소통 : 업무규칙은 엔터티,서브타입,속성,관계등의 형태로 최대한 자세히 표현
6.통합성 : 동일한 데이터는 한 번만 정의, 참조활용
#### 엔터티
엔터티 : 업무에 필요, 유용한 정보를 저장, 관리하기 위한 집합적인 것, 보이지 않는 개념 포함
엔터티의 특징
1. 반드시 해당 업무에서 필요하고 관리하고자 함
2. 유일한 식별자에 의해 식별 가능
3. 두 개 이상의 인스턴스의 집합
4. 업무 프로세스에 의해 이용되어야 함
5. 반드시 속성이 있어야 함
6. 다른 엔터티와 최소 1개 이상의 관계가 있어야 함
- 엔터티의 분류
	유무형에 따른 분류 : 유형, 개념, 사건 엔터티
	유형:물리적 형태 ex)사원, 물품, 강사

==속성== : 업무에서 필요 인스턴스로 관리하고자 하는 의미상 분리되지 않는 ==최소의 데이터 단위==
- 1 개의 엔터티는 2개 이상의 인스턴스 집합 
- 1 개의 엔터티는 2개 이상의 속성을 가짐
- 1 개의 인스턴스는 ==오직 1개의 속성값을 가짐==
- 속성의 분류 : 기본, 설계, 파생 속성
	기본: 업무로부터 추출한 모든 일반적인 속성
	설계: 업무를 규칙화하기 위해 새로 만들거나 변형,정의하는 속성 ex)일련번호
	파생: 다른 속성에 영향 받은 속성, ==빠른성능을 낼 수 있도록== 원래 속성의 값을 계산 -합
	도메인 : 각 속성이 가질 수 있는 값의 범위 ex)5글자
속성의 명명
1. 해당업무에서 사용하는 이름 부여
2. 서술식 속성명은 사용 금지
3. 약어 사용 금지
4. 전체 데이터모델에서 유일성 확보
#### 관계
관계 : 엔터티-인스턴스 사이 논리적인 연관성 존재의 형태나 행위로서 연관성이 부여된 상태
패어링 : 엔터티 안에 인스턴스가 개별적으로 관계를 가지는 것

- ERD에서는 존재적관계와 행위에 의한 관계를 ==구분하지 않고 표기==
- UML에서는 이를 ==구분하여== 연관관계는 실선, 의존관계는 점선으로 표현

관계선택성(관계선택사양) : 필수관계, 선택관계
표기법 : 관계명/관계차수/선택성
⭐ 관계 체크사항
1. 2개의 엔터티 사이에 ==관심있는 연관 규칙o==?
2. 2개의 엔터티 사이에 ==정보의 조합 발생o==?
3. 업무기술서,장표에 관계연결에 대한 ==규칙 서술o?==
4. 업무기술서,장표에 관계연결을 가능케 하는 ==동사o==?
#### 식별자
- 식별자 : 엔터티내에서 인스턴스를 구분하는 구분자 논리 데이터 모델링 단계
- Key는 물리 데이터 모델링 단계에 사용
- 식별자의 특징 : 유일성, 최소성, 불변성, 존재성
	1. 주식별자에 의해 모든 인스턴스들이 ==유일하게 구분==
	2. 주식별자를 구성하는 속성의 수는 유일성을 만족하 는 ==최소의 수가 되어야 함==
	3. 지정된 주식별자의 값은 자주 ==변하지 않아야 함==
	4. 주식별자가 지정이 되면 반드시 ==값이 들어와야 함==
- **식별자 분류**
	대표성 여부 : 주식별자, 보조식별자
	스스로 생성여부 : 내부식별자, 외부식별자
	속성의 수 : 단일식별자, 복합식별자
	대체 여부 : 본질식별자, 인조식별자(사원번호)
- 주식별자 도출기준
	1. 해당 업무에서 자주 이용되는 속성임
	2. 명칭, 내역 등과 같이 ==이름으로 기술되는 것들은 x==
	3. ==복합==으로 주식별자로 구성할 경우 너무 많은 속성x
### 2. 데이터 모델과 성능
성능 데이터 모델링 : DB 성능향상을 목적으로 설계
분석/설계 단계에서 데이터 모델에 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 재업무비용을 최소화 할 수 있는 기회를 가지게 된다.
데이터의 증가가 빠를수록 성능저하에 따른 성능개선 비용은 기하급수적으로 증가하게 된다.
⭐ 성능 데이터 모델링 고려사항 순서
1. 데이터 모델링을 할 때 ==정규화를 정확하게 수행==
2. DB ==용량산정==을 수행한다.
3. DB에 발생되는 ==트랜잭션==의 유형을 파악한다.
4. 용량과 트랜잭션의 유형에 따라 ==반정규화==를 수행
5. 이력모델의 조정, ==PK/FK==조정, ==슈퍼/서브==타입 조정
6. ==성능관점==에서 데이터 모델을 검증한다.
 데이터는 속성간의 함수종속성에 근거해 정규화되어야 한다. 정규화는 필수사항 
함수적 종속성 : 데이터들이 어떤 기준 값에 의해 종속되는 현상 
partial dependency
![[Pasted image 20250306111330.png|500]]
### 정규화
#### 1. 정규형
정규화 : 반복적인 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치되도록 하는 것
- 칼럼에 의한 반복, 중복적인 속성 값을 갖는 형태는 1차 정규화의 대상
- 주제와 안맞는거 다른 테이블로 빼는거(종속된거 뺌) 2차 정규화
반정규화 : 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복,통합, 분리 등을 수행하는 데이터 모델링의 기법일반적으로 정규화시 입력/수정/삭제 성능이 향상되며 반정규화시 조인 성능이 향상된다.

#### 반정규화 
- 반정규화 절차
	1. 반정규화 대상조사(범위처리빈도수, 범위, 통계성)
	2. 다른 방법유도 검토(뷰, 클러스터링, 인덱스 조정)
	3. 반정규화 적용(테이블, 속성, 관계 반정규화)
- 반정규화 대상조사
	1. 자주 사용되는 테이블에 접근하는 프로세스의 수가많고 항상 일정한 범위만을 조회하는 경우
	2. 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없는 경우
	3. 통계성 프로세스에 의해 통계 정보를 필요로 할 때별도의 통계테이블을 생성한다.
	4. 테이블에 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우다른 방법유도 검토
	5. 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 VIEW를 사용한다.
	6. 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 클러스터링을 적용하거나 인덱스를 조정함 대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리할 수 있다. (파티셔닝 기법)
	7. 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.

- 테이블 반정규화
테이블 병합(1:1관계, 1:M관계, 슈퍼/서브타입)
1. 1:1관계를 통합하여 성능향상
2. 1:M관계를 통합하여 성능향상
3. 슈퍼/서브 관계를 통합하여 성능향상
테이블분할(수직분할, 수평분할)
1. 칼럼단위 테이블을 디스크 I/O를 분산처리하기 위해 테이블을 1:1로 분리하여 성능향상
2. 로우단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 로우단위로 테이블을 쪼갬
테이블추가(중복, 통계, 이력, 부분테이블 추가)
1. 다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능 향상
2. SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능을 향상 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재시켜 성능 향상
3. 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중 화된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블을 생성 칼럼 
반정규화
	1. ==중복칼럼== 추가 : 조인에 의해 처리할 때 성능저하 를 예방,중복된 칼럼을 위치시킴
	2. ==파생칼럼== 추가 : 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방
	3. ==이력테이블== 칼럼추가 : 대량의 이력데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해 이력테이블에 기능성 칼럼(최근값 여부, 시작과 종료일자 등)을 추가함
	4. ==응용시스템 오작동을 위한 칼럼== 추가 : 업무적으로는 의미가 없지만 사용자의 실수로 원래 값으로 복구하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법 
- Row Chaining : Row의 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 ==두 개 이상 의 블록에 걸쳐 하나의 Row가 저장되어 있는 형태==
- Row Migration : 데이터 블록에서 ==**수정**==이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식
- 로우 체이닝과 로우 마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 DB 메모리에서 디스크 I/O (input output)가 발생할 때 많은 I/O가 발생하여 성능저하 발생 트랜잭션을 분석하여 적절하게==1:1관계로 분리함==으로 써 성능향상이 가능하도록 해야 한다.
PK에 의해 테이블을 분할하는 방법(파티셔닝)
1. RANGE PARTITION : 대상 테이블이 날짜 또는 숫자값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리되는 경우
2. LIST PARTITION : 지점, 사업소 등 핵심적인 코드값으로 PK가 구성되어 있고 대량의 데이터가 있는 테이블의 경우
3. HASH PARTITION : 지정된 HASH 조건에 따라 해시 알고리즘이 적용되어 테이블이 분리 테이블에 대한 수평/수직분할의 절차
	1. 데이터 모델링을 완성한다.
	2. DB 용량산정을 한다.
	3. 대량 데이터가 처리되는 테이블에 대해 트랜잭션처리 패턴을 분석한다.
	4. 칼럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석하여 집중화된단위로 테이블을 분리하는 것을 검토한다.

슈퍼/서브 타입 모델 : 업무를 구성하는 데이터의 공통과 차이점을 고려하여 효과적 표현
슈퍼/서브 타입 데이터 모델의 변환기술
1. 개별로 발생되는 트랜잭션에 대해서는 개별 테이블 로 구성(OneToOne Type)
2. 슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼+서브타입 테이블로 구성(Plus Type)
3. 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나 의 테이블로 구성(Single Type, All in One Type)
인덱스 특성을 고려한 PK/FK DB 성능향상인덱스의 특징은 ==여러 개의 속성이 하나의 인덱스로 구성되어 있을 때== 앞쪽에 위치한 속성의 값이 비교자로 있어야 좋은 효율을 나타낸다.
앞쪽에 위치한 속성의 값이==가급적 ‘=’ 아니면 최소한 범위 ‘BETWEEN’ ‘<>’ ==가 들어와야 효율적이다.

분산 DB
1. 여러 곳으로 분산되어있는 DB를 하나의 가상 시스 템으로 사용할 수 있도록 한 DB 논리적으로 동일한 시스템에 속하지만, 컴퓨터 네
트워크를 통해 물리적으로 분산되어 있는 데이터집합 분산 DB를 만족하기 위한 6가지 투명성
1. 분할 투명성(단편화) : 하나의 논리적 Relation이 여러 단편으로 분할되어 각 사본이 여러 site에 저장
2. 위치 투명성 : 사용하려는 데이터의 저장 장소 명시 불필요, 위치정보가 시스템 카탈로그에 유지
3. 지역사상 투명성 : 지역 DBMS와 물리적 DB 사이의 Mapping 보장
4. 중복 투명성 : DB 객체가 여러 stie에 중복 되어 있는지 알 필요가 없는 성질
5. 장애 투명성 : 구성요소의 장애에 무관한 트랜잭션의 원자성 유지
6. 병행 투명성 : 다수 트랜잭션 동시 수행시 결과의일관성 유지, TimeStamp, 분산 2단계 Locking 이용
- 분산 DB 장-단점
	장점 : 지역 자치성, 신뢰성 가용성, 효용성 융통성, 빠른 응답속도, 비용절감, 각 지역 사용자 요구 수용
	단점 : 비용증가, 오류의 잠재성 증대, 설계 관리의 복잡성, 불규칙한 응답 속도, 통제의 어려움, 데이터 무결성 위협
- 분산 DB 적용 기법
	1.테이블 위치 분산 : 설계된 테이블을 본사와 지사단위로 분산
	2.테이블 분할 분산 : 각각의 테이블을 쪼개어 분산
	- 수평분할 : 로우 단위로 분리
	- 수직분할 : 칼럼 단위로 분리
	3.테이블 복제 분산 : 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형
	- 부분복제 : 마스터 DB에서 테이블의 일부의 내용만 다른 지역이나 서버에 위치
	- 광역복제 : 마스터 DB 테이블의 내용을 각 지역이나서버에 존재
	4.테이블 요약 분산 : 지역 간에 또는 서버 간에 데이 터가 비슷하지만 서로 다른 유형으로 존재하는 경우
	- 분석요약 : 동일한 테이블 구조를 가지고 있으면서 분산되어 있는 동일한 내용의 데이터를 이용하여 통 합된 데이터를 산출하는 방식
	- 통합요약 : 분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출하는 방식
- 분산 DB 설계를 고려해야 하는 경우
	1. 성능이 중요한 사이트
	2. 공통코드, 기준정보, 마스터 데이터의 성능향상
	3. 실시간 동기화가 요구되지 않는 경우, 거의 실시간의 업무적인 특징을 가지고 있는 경우(?)
	4. 특정 서버에 부하가 집중되어 부하를 분산
	5. 백업 사이트 구성하는 경우

## 2과목
### 기본
SQL 문장들의 종류
==DML== : SELECT, INSERT, UPDATE, DELETE (개발자)
DDL : CREATE, ALTER, DROP, RENAME 
DCL : GRANT, REVOKE
TCL : COMMIT, ROLLBACK

데이터 유형
테이블명과 칼럼명은 반드시 문자로 시작해야한다.
DATETIME 데이터 유형에는 별도로 크기를 지정x
DDL 명령어의 경우 실행시 AUTO COMMIT / DML의 경우 COMMIT을 입력해야 한다.
트랜잭션의 특성
1. 원자성 : 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않아야 함
2. 일관성 : 트랜잭션 실행 전 DB 내용이 잘못 되지않으면 실행 후도 잘못 되지 않아야 함
3. 고립성 : 트랜잭션 실행 도중 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다.
4. 지속성 : 트랜잭션이 성공적으로 수행되면 DB의내용은 영구적으로 저장된다.
연산자 우선순위 : ( )->NOT->비교연산자->AND->OR
ROWNUM : 원하는 만큼의 행을 가져올 때 사용(Or)
WHERE ROWNUM =1;
NVL(A,B) : NULL 이면 B, NOT NULL 이면 A
- NULLIF(A,B) :  A=B : NULL, A≠B : A 반환 COL1 = 20 COL2 = 20 같으면 20이 아니라 NULL반환
==COALESCE== (PHONE, EMAIL, FAX) NULL이 아닌 첫 번째 값을 반환하는 유용한 함수. 
	1. 함수는 왼쪽에서 오른쪽으로 인자를 순서대로 확인하며, NULL이 아닌 첫 번째 값을 반환
	2. 모든 인자가 NULL인 경우에는 NULL을 반환
- NVL2(A, B, C) : A≠NULL : B , A=NULL : C (없으면 리뷰없음 있으면 리뷰있음)
- DISTINCT : 같은 값을 하나의 데이터로 간주 옵션
- COUNT(표현식) : NULL 제외 행의 수
- GROUP BY, HAVING 절의 특징
	1. GROUP BY 절을 통해 소그룹별 기준을 정한 후, SELECT 절에 집계 함수를 사용한다.
	2. 집계 함수의 통계 정보는 NULL 값을 가진 행을 제외하고 수행한다.
	3. GROUP BY 절에서는 ALIAS 사용 불가
	4. 집계 함수는 WHERE 절에 올 수 없다.
	5. HAVING 절에는 집계함수를 이용하여 조건 표시o
	6. HAVING 절은 일반적으로 GROUP BY 뒤에 위치

- ORDER BY 절에 칼럼명 대신 ALIAS 명이나 칼럼 순서를 나타내는 정수도 사용 가능하다.
JOIN : 두 개 이상의 테이블들을 연결 또는 결합하여 데이터를 출력하는것
일반적으로 행들은 PK나 FK 값의 연관에 의해 JOIN 이 성립된다. 
어떤 경우에는 PK, FK 관계가 없어도 논리적인 값들의 연관만으로 JOIN이 성립가능하다.
5가지 테이블을 JOIN 하기 위해서는 최소 4번의 JOIN 과정이 필요하다. (N-1)

순수 관계 연산자 : 관계형 DB를 새롭게 구현
1. SELECT -> WHERE
2. PROJECT -> SELECT
3. NATRUAL JOIN -> 다양한 JOIN
4. DIVIDE -> 사용x

FROM 절 JOIN 형태
1. INNER JOIN
2. NATURAL JOIN
3. USING 조건절
4. ON 조건절
5. CROSS JOIN
6. OUTER JOIN
INNER JOIN : JOIN 조건에서 동일한 값 행만 반환, ==USING이나 ON 절을 필수==적으로 사용
NATURAL JOIN : 두 테이블 간의 동일한 이름을 갖 는 모든 칼럼들에 대해 EQUI JOIN 수행, NATURAL JOIN이 명시되면 추가로 USING, ON, WHERE 절에 서 JOIN 조건을 정의할 수 없다, SQL Sever는 지원x
- USING 조건절
같은 이름을 가진 칼럼들 중에서 원하는 칼럼에 대해 서만 선택적으로 EQUI JOIN을 할 수 있다, JOIN 칼럼에 대해서 AS나 테이블명과 같은 접두사를 붙일 수 없다, SQL Server 지원x
- ON 조건절
ON 조건절과 WHERE 조건절을 분리하여 이해가 쉬우며, 칼럼명이 다르더라도 JOIN 조건을 사용할 수 있 는 장점이 있다, ALIAS나 테이블명 반드시 사용
- CROSS JOIN
양쪽 집합의 M*N건의 데이터 조합이 발생한다.
- OUTER JOIN
JOIN 조건에서 동일한 값이 없는 행도 반환 가능, USING이나 ON 조건절 반드시 사용
- LEFT OUTER JOIN
조인 수행시 먼저 표기된 좌측 테이블에 해당하는 데 이터를 읽은 후, 나중 표기된 우측 테이블에서 JOIN 대상 데이터를 읽어 온다. 우측 값에서 같은 값이 없 는 경우 NULL 값으로 채운다.
- RIGHT OUTER JOIN
	LEFT OUTER JOIN의 반대
- FULL OUTER JOIN
조인 수행시 좌측, 우측 테이블의 모든 데이터를 읽어 JOIN하여 결과를 생성한다. 중복 데이터는 삭제한다.

계층형 질의 : 테이블에 계층형 데이터가 존재하는 경우 데이터를 조회하기 위해 사용
- SATRT WITH : 계층 구조 전개의 시작 위치 지정
- CONNECT BY : 다음에 전개될 자식 데이터 지정
- PRIOR : CONNECT BY 절에 사용되며, 현재 읽은 칼럼을 지정한다. PRIOR 자식 = 부모 형태를 사용하면 계층구조에서 부모 데이터에서 자식 데이터(부모->자식) 방향으로 전개하는 순방향 전개를 한다. 반대는역방향 전개
- NOCYCLE : 동일한 데이터가 전개되지 않음
- ORDER SIBLINGS BY : 형제 노드간의 정렬 수행
- LEVEL : 루트 데이터이면 1, 그 하위 데이터면 2, 리프 데이터까지 1씩 증가
- CONNECT_BY_ISLEAF : 해당 데이터가 리프 데이터면1, 그렇지 않으면 0
- SYS_CONNECT_BY_PATH : 루트 데이터부터 현재전개할 데이터까지의 경로를 표시.
- CONNECT_BY_ROOT : 현재 전개할 데이터의 루트데이터를 표시한다. 단항 연산자이다.

- 셀프 조인 : 동일 테이블 사이의 조인, FROM 절에 동일 테이블이 2번 이상 나타난다. 반드시 테이블 별칭을 사용해야 함
- 서브 쿼리 사용시 주의 사항
	1. 서브쿼리를 괄호로 감싸서 사용한다.
	2. 서브쿼리는 단일 행 또는 복수 행 비교 연산자와 함께 사용 가능. 단일행 비교 연산자는 서브쿼리 의 결과가 반드시 1건 이하여야 하고 복수 행 비교 연산자는 결과 건수와 상관없다.
	3. 서브쿼리에서는 ORDER BY를 사용하지 못한다.
	4. SELECT, FROM, WHERE, HAVING, ORDER BY, INSERT-VALUES, UPDATE-SET 절에 사용 가능

단일 행 비교 연산자 : =,<,>,<> 등
다중 행 비교 연산자 : IN, ALL, ANY, SOME 등
스칼라 서브쿼리 : 한 행, 한 칼럼만을 반환하는 서브쿼리
인라인 뷰 : 테이블 명이 올 수 있는 곳에 사용, ORDER BY 사용 가능
뷰 : 테이블은 실제 데이터, 뷰는 실제 데이터를 가지고 있지 않다. 가상 테이블이라 함
뷰 사용 장점
1. 독립성 : 테이블 구조가 변경되어도 ==응용 플그램은 변경하지 않아도 된다.==
2. 편리성 : 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성할 수 있다.
3. 보안성 : 직원의 급여정보와 같이 숨기고 싶은 정보가 존재할 때 사용

Grouping Columns의 수를 N이라고 했을 때 N+1 Level의 Subtotal이 생성된다. 인수 순서에 주의
GROUPING : Subtotal의 total을 생성
CUBE : 결합 가능 모든 값에 다차원 집계 생성, ROLLUP에 비해 시스템에 부하 심함
GROUPING SETS : 인수들에 대한 개별 집계를 구할수 있다, 다양한 소계 집합 생성 가능

윈도우 함수 : 행과 행간의 관계를 정의하거나 행과 행간을 비교, 연산하는 함수
RANK : 1,2,2,4
DENSE_RANK : 1,2,2,3
ROW_NUMBER : 동일한 값이라도 고유한 순위 부여 
- AVG : 원하는 조건에 맞는 데이터에 대한 통계 값 ex)같은 매니저 내에서 앞의 사번과 뒤의 사번의 평균
	ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
	(현재 행을 기준으로 파티션 내에서 앞의 1건, 현재 행, 뒤의 1건을 범위로 지정)

RATIO_TO_REPORT 
	`RATIO_TO_REPORT(SCORE) OVER()` 뜻은 스코어/총합
- PERCENT_RANK : 맨위행=0 끝행=1 ▶ RAINK-1/ 총 카운트에서 -1
	10개중에 9번째 순위 : 8/9
- CUME_DIST : 누적 백분위 누적건수/전체건수
- NTILE : N등분후 현재 등급 구하기 

GRANT : 권한 부여
REVOKE : 권한 취소
ROLE : 유저에게 알맞은 권한들을 한 번에 부여하기위해 사용하는 것
CASCADE : 하위 오브젝트까지 삭제

- COL1/COL2 에서 20/0 이라면 ==에러가 발생한다== 0은 나눌수 없음

`WHERE INJURIED <> 'Y'` ▶부상이 아닌 선수 <>같지 않음. 
- NOT AND OR 순으로 처리
- BETWEEN A AND B : A ==이상== B ==이하==
- LIKE '%비교문자열' %는 어쩌구로 번역하면 됨.
	#% 는 말 그대로 %가 들어간 행을 찾을때
	EACAPE 기호는 아무거나 정해도 됨 ESCAPE = # 이런식으로 ESCAPE = @ 
- IN(LIST) : 리스트중 하나와 일치. `WHERE POSTION IN ('ST','LW','RW')`
- IS NULL : COL1 이 NULL인 데이터 출력할 때 사용

- 주로 ==GROUP BY== 뒤에 오면서 데이터 조건을 부여함. 
- TABLE 전체가 한개의 그룹이 되는 경우 HAVING 으로만 사용 가능

- ORDER BY는 SELECT절에서 ==제일 마지막에== 수행
- 정렬시 컬럼이 따로 놀지 않아야 함 기준에 맞게 정렬 후 최댓값 등 찾기
- ORDER BY 1,2 ; 이런식으로 가능. 기본값 오름차순 1열2열 오름차순이라는 뜻

 (+)는 Oracle 데이터베이스에서 사용되는 외부 조인(Outer Join) 연산자
1. **외부 조인 표시**: (+)는 해당 테이블이 외부 조인의 "선택적" 테이블임을 나타냅니다.
2. **NULL 값 허용**: (+)가 있는 쪽의 테이블에서 일치하는 행이 없어도 결과에 포함됩니다.

SAMPLE1 테이블의 모든 행을 기준으로, 일치하는 SAMPLE2와 SAMPLE3의 데이터를 가져오되, 일치하지 않는 경우에도 SAMPLE1의 데이터는 모두 표시하는 결과를 생성

- INNER JOIN
==ON== 절을 사용해서 작성. 
- `FROM PRODUCT A INNER JOIN PRODUCT_REVIEW B`
	`ON A.PRODUCT_CODE = B.PRODUCT_CODE;`
- 2개 테이블에 같은 이름 가진 컬럼들이 모두 동일한 데이터 가질 경우
	JOIN이 되는 방식으로 ==공통 칼럼 앞에 테이블 명이나 AS를 붙이면 에러가 발생.== 
	`SELECT D.DEP_NO, E.EMP_ID
	FROM EMP E NATURAL JOIN DEP D;`

ROLLUP함수는 인수의 순서에 따라 결과가 달라짐짐
CUBE와 GROUPING SETS 함수는 인수의 순서가 바뀌어도 동일한 결과 출력
- LAG : 앞선 데이터 구하는 함수  ==내가 얼마나 LAGGING 되어있나==
- LEAD : 뒤에 있는 데이터 ==내가 얼마나 리드하고 있는 데이터==
WHERE 절보다 나중에 수행

#### 8.  계층 쿼리
- JOIN 없이도 계층구조 출력
- LEVEL : 루트노드는 = 1
- SYS_CONNET_BY_PATH(컬럼,구분자)
- START WITH : 경로가 시작되는 루트 노트 
- CONNECT BY : 루트부터 자식노드를 생성해주는 절 
- PRIOR : 부모 노드 반환 
